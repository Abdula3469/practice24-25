# -*- coding: utf-8 -*-
"""код практика конечный.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hJRF4Qqt7oqGt_4lDPQijvIBSUe_Sqtl
"""

import os
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
import seaborn as sns

# В данном коде я буду немало пользоваться print, чтобы было проще отслеживать процесс его работы
print("Загрузка и подготовка данных")


fashion_mnist = tf.keras.datasets.fashion_mnist
(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()


train_images = train_images / 255.0
test_images = test_images / 255.0


class_names = ["Футболка", "Брюки", "Пуловер", "Платье", "Пальто",
               "Босоножка", "Рубашка", "Кроссовок", "Сумка", "Ботинок"]


plt.figure(figsize=(10, 10))
for i in range(9):
    plt.subplot(3, 3, i+1)
    plt.imshow(train_images[i], cmap=plt.cm.binary)
    plt.title(class_names[train_labels[i]])
    plt.axis('off')
plt.show()


print("Проектирование нейронной сети")



model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10, activation='softmax')
])


model.summary()


print("Обучение нейронной сети")


model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])


history = model.fit(train_images, train_labels,
                   epochs=15,
                   validation_split=0.2,
                   verbose=1)



improved_model = tf.keras.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)),
    tf.keras.layers.MaxPooling2D((2,2)),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D((2,2)),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')
])

improved_model.compile(optimizer='adam',
                      loss='sparse_categorical_crossentropy',
                      metrics=['accuracy'])


improved_history = improved_model.fit(
    train_images.reshape(-1,28,28,1), train_labels,
    epochs=15,
    validation_split=0.2
)


base_test_loss, base_test_acc = model.evaluate(test_images, test_labels, verbose=2)
print(f"\nТочность базовой модели: {base_test_acc:.2%}")


improved_test_loss, improved_test_acc = improved_model.evaluate(
    test_images.reshape(-1,28,28,1), test_labels, verbose=2)
print(f"\nТочность улучшенной модели: {improved_test_acc:.2%}")


plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Точность на обучении')
plt.plot(history.history['val_accuracy'], label='Точность на валидации')
plt.xlabel('Эпоха')
plt.ylabel('Точность')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Потери на обучении')
plt.plot(history.history['val_loss'], label='Потери на валидации')
plt.xlabel('Эпоха')
plt.ylabel('Потери')
plt.legend()
plt.show()


plt.subplot(2, 2, 3)
plt.plot(improved_history.history['accuracy'], label='Обучение (CNN)')
plt.plot(improved_history.history['val_accuracy'], label='Валидация (CNN)')
plt.title('Точность улучшенной модели')
plt.xlabel('Эпохи')
plt.ylabel('Точность')
plt.legend()


plt.subplot(2, 2, 4)
plt.plot(improved_history.history['loss'], label='Обучение (CNN)')
plt.plot(improved_history.history['val_loss'], label='Валидация (CNN)')
plt.title('Потери улучшенной модели')
plt.xlabel('Эпохи')
plt.ylabel('Потери')
plt.legend()

plt.tight_layout()
plt.show()


print("Оценка результатов")


def plot_image(i, predictions_array, true_label, img):
    true_label, img = true_label[i], img[i]
    plt.grid(False)
    plt.xticks([])
    plt.yticks([])
    plt.imshow(img, cmap=plt.cm.binary)

    predicted_label = np.argmax(predictions_array)
    color = 'blue' if predicted_label == true_label else 'red'

    plt.xlabel("{} {:2.0f}% ({})".format(class_names[predicted_label],
                                         100*np.max(predictions_array),
                                         class_names[true_label]),
                                         color=color)

def plot_value_array(i, predictions_array, true_label):
    true_label = true_label[i]
    plt.grid(False)
    plt.xticks(range(10))
    plt.yticks([])
    thisplot = plt.bar(range(10), predictions_array, color="#777777")
    plt.ylim([0, 1])
    predicted_label = np.argmax(predictions_array)

    thisplot[predicted_label].set_color('red')
    thisplot[true_label].set_color('blue')


predictions = model.predict(test_images)


num_rows = 5
num_cols = 3
num_images = num_rows*num_cols
plt.figure(figsize=(2*2*num_cols, 2*num_rows))
for i in range(num_images):
    plt.subplot(num_rows, 2*num_cols, 2*i+1)
    plot_image(i, predictions[i], test_labels, test_images)
    plt.subplot(num_rows, 2*num_cols, 2*i+2)
    plot_value_array(i, predictions[i], test_labels)
plt.tight_layout()
plt.show()


preds = model.predict(test_images)
cm = confusion_matrix(test_labels, np.argmax(preds, axis=1))
plt.figure(figsize=(10,8))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Предсказанный класс')
plt.ylabel('Истинный класс')
